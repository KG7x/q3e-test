; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	bin2hex.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG1472	DB	'Usage: %s <input_file> [+]<output_file> <output_array_na'
	DB	'me>', 0aH, 00H
	ORG $+3
$SG1474	DB	'Array name is too long: %s', 0aH, 00H
$SG1475	DB	'rb', 00H
	ORG $+1
$SG1477	DB	'Could not open file for reading: %s', 0aH, 00H
	ORG $+3
$SG1479	DB	'Seek error for: %s', 0aH, 00H
$SG1481	DB	'Seek error for: %s', 0aH, 00H
$SG1483	DB	'ab', 00H
	ORG $+1
$SG1485	DB	'wb', 00H
	ORG $+1
$SG1487	DB	'Could not open file for writing: %s', 0aH, 00H
	ORG $+3
$SG1488	DB	'const unsigned char %s[%li] = {', 0aH, 09H, 00H
	ORG $+2
$SG1492	DB	'0x%.2X', 00H
	ORG $+1
$SG1495	DB	', ', 00H
	ORG $+1
$SG1497	DB	',', 0aH, 09H, 00H
$SG1499	DB	0aH, '};', 0aH, 00H
	ORG $+3
$SG1501	DB	'Could not read entire file: %s', 00H
_DATA	ENDS
PUBLIC	_main
EXTRN	_fclose:NEAR
EXTRN	_fflush:NEAR
EXTRN	_fgetc:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fputs:NEAR
EXTRN	_fseek:NEAR
EXTRN	_ftell:NEAR
EXTRN	_fwrite:NEAR
EXTRN	_printf:NEAR
EXTRN	_sprintf:NEAR
; Function compile flags: /Ogty
; File d:\mydocs\quake3\q3e\code\renderervk\shaders\bin2hex.c
_TEXT	SEGMENT
_size$ = -260						; size = 4
_buf$ = -256						; size = 256
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC NEAR

; 5    : int main( int argc, const char* argv[] ) {

	sub	esp, 260				; 00000104H

; 6    : 	const int line_length = 16;
; 7    : 	int size = 0;
; 8    : 	char buf[256];
; 9    : 	FILE *f_in;
; 10   : 	long in_len;
; 11   : 	FILE *f_out;
; 12   : 	int c, n;
; 13   : 
; 14   : 	if ( argc != 4 ) {

	cmp	DWORD PTR _argc$[esp+256], 4
	mov	DWORD PTR _size$[esp+260], 0
	je	SHORT $L1471

; 15   : 		printf("Usage: %s <input_file> [+]<output_file> <output_array_name>\n", argv[0] );

	mov	eax, DWORD PTR _argv$[esp+256]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET FLAT:$SG1472
	call	_printf
	add	esp, 8

; 16   : 		return - 1;

	or	eax, -1

; 105  : }

	add	esp, 260				; 00000104H
	ret	0
$L1471:
	push	ebp

; 17   : 	}
; 18   : 
; 19   : 	if ( strlen( argv[3] ) > sizeof( buf ) - 64 ) {

	mov	ebp, DWORD PTR _argv$[esp+260]
	mov	edx, DWORD PTR [ebp+12]
	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	npad	7
$L1511:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L1511
	sub	eax, esi
	cmp	eax, 192				; 000000c0H
	jbe	SHORT $L1473

; 20   : 		printf( "Array name is too long: %s\n", argv[3] );

	push	edx
	push	OFFSET FLAT:$SG1474
	call	_printf
	add	esp, 8
	pop	esi

; 21   : 		return -1;

	or	eax, -1
	pop	ebp

; 105  : }

	add	esp, 260				; 00000104H
	ret	0
$L1473:

; 22   : 	}
; 23   : 
; 24   : 	f_in = fopen( argv[1], "rb" );

	mov	edx, DWORD PTR [ebp+4]
	push	ebx
	push	OFFSET FLAT:$SG1475
	push	edx
	call	_fopen
	mov	ebx, eax
	add	esp, 8

; 25   : 
; 26   : 	if ( !f_in ) {

	test	ebx, ebx
	jne	SHORT $L1476

; 27   : 		printf( "Could not open file for reading: %s\n", argv[1] );

	mov	eax, DWORD PTR [ebp+4]
	push	eax
	push	OFFSET FLAT:$SG1477
	call	_printf
	add	esp, 8
	pop	ebx
	pop	esi

; 28   : 		return -1;

	or	eax, -1
	pop	ebp

; 105  : }

	add	esp, 260				; 00000104H
	ret	0
$L1476:

; 29   : 	}
; 30   : 
; 31   : 	if ( fseek( f_in, 0, SEEK_END ) ) {

	push	2
	push	0
	push	ebx
	call	_fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L1478

; 32   : 		printf( "Seek error for: %s\n", argv[1] );

	mov	ecx, DWORD PTR [ebp+4]
	push	ecx
	push	OFFSET FLAT:$SG1479
$L1518:
	call	_printf

; 33   : 		fclose( f_in );

	push	ebx
	call	_fclose
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	esi

; 34   : 		return -1;

	or	eax, -1
	pop	ebp

; 105  : }

	add	esp, 260				; 00000104H
	ret	0
$L1478:

; 35   : 	}
; 36   : 
; 37   : 	in_len = ftell( f_in );

	push	ebx
	call	_ftell

; 38   : 
; 39   : #if 0
; 40   : 	if ( in_len & 3 ) {
; 41   : 		printf( "Incorrect size %li: %s\n", in_len, argv[1] );
; 42   : 		fclose( f_in );
; 43   : 		return -1;
; 44   : 	}
; 45   : #endif
; 46   : 
; 47   : 	if ( fseek( f_in, 0, SEEK_SET ) ) {

	push	0
	push	0
	push	ebx
	mov	esi, eax
	call	_fseek
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $L1480

; 48   : 		printf( "Seek error for: %s\n", argv[1] );

	mov	edx, DWORD PTR [ebp+4]
	push	edx
	push	OFFSET FLAT:$SG1481

; 49   : 		fclose( f_in );
; 50   : 		return -1;

	jmp	SHORT $L1518
$L1480:

; 51   : 	}
; 52   : 
; 53   : 	if ( argv[2][0] == '+' ) // append mode

	mov	eax, DWORD PTR [ebp+8]
	cmp	BYTE PTR [eax], 43			; 0000002bH
	push	edi
	jne	SHORT $L1482

; 54   : 		f_out = fopen( argv[2]+1, "ab" );

	push	OFFSET FLAT:$SG1483
	inc	eax

; 55   : 	else

	jmp	SHORT $L1517
$L1482:

; 56   : 		f_out = fopen( argv[2], "wb" );

	push	OFFSET FLAT:$SG1485
$L1517:
	push	eax
	call	_fopen
	mov	edi, eax
	add	esp, 8

; 57   : 
; 58   : 	if ( !f_out ) {

	test	edi, edi
	jne	SHORT $L1486

; 59   : 		printf( "Could not open file for writing: %s\n", argv[2] );

	mov	eax, DWORD PTR [ebp+8]
	push	eax
	push	OFFSET FLAT:$SG1487
	call	_printf

; 60   : 		fclose( f_in );

	push	ebx
	call	_fclose
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 61   : 		return -1;

	or	eax, -1
	pop	ebp

; 105  : }

	add	esp, 260				; 00000104H
	ret	0
$L1486:

; 62   : 	}
; 63   : 
; 64   : 	n = sprintf( buf, "const unsigned char %s[%li] = {\n\t", argv[3], in_len );

	mov	ecx, DWORD PTR [ebp+12]
	push	esi
	push	ecx
	lea	edx, DWORD PTR _buf$[esp+284]
	push	OFFSET FLAT:$SG1488
	push	edx
	call	_sprintf

; 65   : 
; 66   : 	fwrite( buf, n, 1, f_out );

	push	edi
	push	1
	push	eax
	lea	eax, DWORD PTR _buf$[esp+304]
	push	eax
	call	_fwrite

; 67   : 
; 68   : 	c = fgetc( f_in );

	push	ebx
	call	_fgetc
	mov	esi, eax
	add	esp, 36					; 00000024H

; 69   : 
; 70   : 	while ( c != EOF ) {

	cmp	esi, -1
	je	SHORT $L1493
$L1490:

; 71   : 
; 72   : 		n = sprintf( buf, "0x%.2X", c );

	push	esi
	lea	ecx, DWORD PTR _buf$[esp+280]
	push	OFFSET FLAT:$SG1492
	push	ecx
	call	_sprintf

; 73   : 		fwrite( buf, n, 1, f_out );

	push	edi
	push	1
	push	eax
	lea	edx, DWORD PTR _buf$[esp+300]
	push	edx
	call	_fwrite

; 74   : 
; 75   : 		c = fgetc( f_in );

	push	ebx
	call	_fgetc

; 76   : 
; 77   : 		size++;

	mov	ecx, DWORD PTR _size$[esp+308]
	add	esp, 32					; 00000020H
	mov	esi, eax
	inc	ecx

; 78   : 
; 79   : 		if ( c != EOF ) {

	cmp	esi, -1
	mov	DWORD PTR _size$[esp+276], ecx
	je	SHORT $L1493

; 80   : 			if ( size % line_length ) 

	mov	eax, ecx
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $L1516
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$L1516:

; 81   : 				fputs( ", ", f_out );

	push	edi

; 80   : 			if ( size % line_length ) 

	je	SHORT $L1494

; 81   : 				fputs( ", ", f_out );

	push	OFFSET FLAT:$SG1495
	call	_fputs
	add	esp, 8

; 82   : 			else

	jmp	SHORT $L1490
$L1494:

; 83   : 				fputs( ",\n\t", f_out );

	push	OFFSET FLAT:$SG1497
	call	_fputs
	add	esp, 8
	jmp	SHORT $L1490
$L1493:

; 84   : 		} else {
; 85   : 			break;
; 86   : 		}
; 87   : 	}
; 88   : 
; 89   : 	fputs( "\n};\n", f_out );

	push	edi
	push	OFFSET FLAT:$SG1499
	call	_fputs

; 90   : 
; 91   : #if 0
; 92   : 	n = sprintf( buf, "const int %s_size = %i;\n", argv[3], size );
; 93   : 	fwrite( buf, n, 1, f_out );
; 94   : #endif
; 95   : 
; 96   : 	if ( !feof( f_in ) ) {

	mov	al, BYTE PTR [ebx+12]
	add	esp, 8
	test	al, 16					; 00000010H
	jne	SHORT $L1500

; 97   : 		printf( "Could not read entire file: %s", argv[1] );

	mov	ecx, DWORD PTR [ebp+4]
	push	ecx
	push	OFFSET FLAT:$SG1501
	call	_printf
	add	esp, 8
$L1500:

; 98   : 	}
; 99   : 
; 100  : 	fflush( f_out );

	push	edi
	call	_fflush

; 101  : 	fclose( f_out );

	push	edi
	call	_fclose

; 102  : 	fclose( f_in );

	push	ebx
	call	_fclose
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 103  : 
; 104  : 	return 0;

	xor	eax, eax
	pop	ebp

; 105  : }

	add	esp, 260				; 00000104H
	ret	0
_main	ENDP
_TEXT	ENDS
END
